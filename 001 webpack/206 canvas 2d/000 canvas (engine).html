<!DOCTYPE html> 
<html>
<head>
	<meta charset="utf-8" />
	<title></title>
	<style>
		html, body {
	      width:  100%;
	      height: 100%;
	      margin: 0;
	    }
	</style>
</head>
<body>
	<canvas id="canv" width="150" height="150"></canvas>
	<div style="position: absolute; top: 0; left: 15px" id='fpsNow'>0</div>
	<div style="display: inline-block; position: absolute; left: 0; top: 0;"class="anim" id='block1'>1</div>
<script>
//таски:
// 01 сделать подсчет fps более точным( рассчитывать разницу между самыми медленными кадрами и вставлять это число)
// 02 при ресайзе что запускать redraw или gameMech


/*--------*/
/* State */
let MyGame= {};
//canvas
let htmlCanvas = document.getElementById('canv');

// context
let context = htmlCanvas.getContext('2d');

//настройки производительности
//если поставить больше герцовки монитора то - не будет отрисовывать больше
let FrameLimitFPS = 100;
//если true - используем рендер с лимитом кадров(можно включить больше герцовки монитора)
//если false - рендер использует все возможности компьютера(включать только на мощных компьютерах)
let useFrameLimitRender = true;


//рассчет fps
let fpsArr = [];
let fpsCurSec = 0;
let fpsNowBlock = document.getElementById("fpsNow");


//игровой предмет(только для дэмо - УДАЛИТЬ)
let block1 = document.getElementById("block1");


/*---------*/
/* Engine */
	(function () {
		function main( tFrame ) {
			//запускать requestAnimationFrame нужно именно здесь(чтобы браузер получил кадр вовремя)
		MyGame.stopMain = window.requestAnimationFrame( main );

		let nextTick = MyGame.lastTick + MyGame.tickLength;
		let numTicks = 0;

		if (tFrame > nextTick) {
			let timeSinceTick = tFrame - MyGame.lastTick;
			numTicks = Math.floor( timeSinceTick / MyGame.tickLength );
		}


		if(!useFrameLimitRender){
		  	render( tFrame );
		}
		else{
			if(numTicks){
				MyGame.lastTick = MyGame.lastTick + MyGame.tickLength; // Now lastTick is this tick.
		  		render(tFrame);
			}
		}

		}

		//если useFrameLimitRender = true
		MyGame.lastTick = performance.now();
		MyGame.tickLength = 1000/FrameLimitFPS;

		setInitialState();
		main(performance.now()); // Start the cycle
	})();


/*----------------*/
/* Initial State */
	function setInitialState(){
		//console.log('start once');
		window.addEventListener('resize', resizeCanvas, false);
		resizeCanvas();
	};

/*----------*/
/* Resizer */
function resizeCanvas() {
	console.log('---resize')
	htmlCanvas.width = window.innerWidth;
	htmlCanvas.height = window.innerHeight;
	redraw();
}


/*------*/
/* FPS */
function fps(tick){
	let prevTick;
	let mostLowerInterval;

	//console.log(Math.floor(tick/1000));
	if(Math.floor(tick/1000)===fpsCurSec){
		fpsArr.push('');
	}
	else{
		fpsNowBlock.innerHTML = fpsArr.length;
		fpsArr = [''];
		fpsCurSec = Math.floor(tick/1000);
	}
}


/*---------*/
/* Render */
function render(tick){
	gameMech(tick);
	fps(tick);
};


/*----------------*/
/* Game Mechanic */
function gameMech(tick){
	block1.style.transform = "rotate("+tick/1.3+"deg)";
}


/*-------*/
/* Draw */
function redraw() {
	context.strokeStyle = 'red';
	context.lineWidth = '1';
	context.strokeRect(0, 0, window.innerWidth, window.innerHeight);
}

</script>

<body>
	
</body>
</html>