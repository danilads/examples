<!DOCTYPE html> 
<html>
<head>
	<meta charset="utf-8" />
	<title></title>
	<style>
		html, body {
	      width:  100%;
	      height: 100%;
	      margin: 0;
	    }
	</style>
</head>
<body>
	<canvas id="canv" width="150" height="150"></canvas>
	<div style="position: absolute; top: 0; left: 15px" id='fpsNow'>0</div>
	<div style="display: inline-block; position: absolute; left: 6px; top: 0;"class="anim" id='block1'>|</div>
<script>
//таски:
// при ресайзе что запускать redraw или gameMech


/*--------*/
/* State */
let MyGame= {};
//canvas
let htmlCanvas = document.getElementById('canv');

// context
let context = htmlCanvas.getContext('2d');

//настройки производительности
//если поставить больше герцовки монитора то - не будет отрисовывать больше
let FrameLimitFPS = 60;
//если true - используем рендер с лимитом кадров(можно включить больше герцовки монитора)
//если false - рендер использует все возможности компьютера(включать только на мощных компьютерах)
let useFrameLimitRender = true;


//рассчет fps
//fpsNow
let fpsNowArr = [];
let fpsCurSec = 0;
let fpsNowBlock = document.getElementById("fpsNow");



//игровой предмет(только для дэмо - УДАЛИТЬ)
let block1 = document.getElementById("block1");


/*---------*/
/* Engine */
	(function () {
		function main( tFrame ) {
			//запускать requestAnimationFrame нужно именно здесь(чтобы браузер получил кадр вовремя)
			MyGame.stopMain = window.requestAnimationFrame( main );

			let nextTick = MyGame.lastTick + MyGame.tickLength;
			let numTicks = 0;

			if (tFrame > nextTick) {
				let timeSinceTick = tFrame - MyGame.lastTick;
				numTicks = Math.floor( timeSinceTick / MyGame.tickLength );
			}


			if(!useFrameLimitRender){
			  	render( tFrame );
			}
			else{
				if(numTicks===1){
					MyGame.lastTick = MyGame.lastTick + MyGame.tickLength; // Now lastTick is this tick.
			  		render(tFrame);
				}
				//был баг - если перейти на другую вкладку а потом вернуться - ограничение фпс слетало
				else if(numTicks>1){
					MyGame.lastTick = performance.now();
				}
			}

		}

		setInitialState();
		MyGame.lastTick = performance.now();
		MyGame.tickLength = 1000/FrameLimitFPS;

		
		main(performance.now()); // Start the cycle
	})();


/*----------------*/
/* Initial State */
	function setInitialState(){
		//console.log('start once');
		window.addEventListener('resize', resizeCanvas, false);
		resizeCanvas();
	};

/*----------*/
/* Resizer */
function resizeCanvas() {
	console.log('---resize')
	htmlCanvas.width = window.innerWidth;
	htmlCanvas.height = window.innerHeight;
	redraw();
}


/*------*/
/* FPS */
function fps(tick){
	//console.log(Math.floor(tick/1000));
	let roundTick = Math.floor(tick/1000);
	if(roundTick===fpsCurSec){
		fpsNowArr.push('');
	}
	else{
		fpsNowBlock.innerHTML = fpsNowArr.length;
		fpsNowArr = [''];
		fpsCurSec = roundTick;
	}
}


/*---------*/
/* Render */
function render(tick){
	gameMech(tick);
	fps(tick);
};


/*----------------*/
/* Game Mechanic */
function gameMech(tick){
	block1.style.transform = "rotate("+tick/1.3+"deg)";
}


/*-------*/
/* Draw */
function redraw() {
	context.strokeStyle = 'blue';
	context.lineWidth = '1';
	context.strokeRect(0, 0, window.innerWidth, window.innerHeight);
}

</script>

<body>
	
</body>
</html>